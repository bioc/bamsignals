% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/wrappers.R
\docType{methods}
\name{bamsignals-methods}
\alias{bamsignals-methods}
\alias{count}
\alias{count,GenomicRanges,character-method}
\alias{depth}
\alias{depth,GenomicRanges,character-method}
\alias{pileup}
\alias{pileup,GenomicRanges,character-method}
\title{Functions for extracting count signals from a bam file.}
\usage{
\S4method{count}{GenomicRanges,character}(gr, bampath, mapqual = 0,
  shift = 0, ss = F, paired.end = F, paired.end.midpoint = F,
  paired.end.max.frag.length = 1000, verbose = T)

\S4method{pileup}{GenomicRanges,character}(gr, bampath, binsize = 1,
  mapqual = 0, shift = 0, ss = F, paired.end = F,
  paired.end.midpoint = F, paired.end.max.frag.length = 1000, verbose = T)

\S4method{depth}{GenomicRanges,character}(gr, bampath, mapqual = 0,
  paired.end = F, paired.end.max.frag.length = 1000, verbose = T)
}
\arguments{
\item{gr}{GenomicRanges object used to specify the regions}

\item{bampath}{path to the bam file storing the read. The file must be indexed.
If a range is on the negative strand the profile will be reverse-complemented.}

\item{mapqual}{discard reads with mapping quality strictly lower than this parameter.
The value 0 ensures that no read will be discarded, the value 254 that only reads
with the highest possible mapping quality will be considered.}

\item{shift}{shift the read position by a user-defined number of basepairs. This can
be handy in the analysis of chip-seq data.}

\item{ss}{produce a strand-specific profile or ignore the strand of the read. This option
does not have any effect on the strand of the region. Strand-specific profiles are
twice as long then strand-independent profiles.}

\item{paired.end}{a logical value indicating whether the bampath contains paired-end
sequencing output. In this case, only first reads in proper mapped pairs are considered.}

\item{paired.end.midpoint}{a logical value indicating whether the fragment middle
points of each fragment should be counted. Therefore it uses the tlen information from
the given bam file (MidPoint = fragment_start + int( abs(tlen) / 2) )). For even tlen,
the given midpoint will be moved of 0.5 basepairs in the 3' direction.}

\item{paired.end.max.frag.length}{an integer indicating which fragments should be
considered in paired-end sequencing data. Default value of 1,000 bases is generally
a good pick.}

\item{verbose}{a logical value indicating whether verbose output is desired}

\item{binsize}{If the value is set to 1, the method will return basepair-resolution read densities,
for bigger values the density profiles will be binned (and the memory requirements
will scale accordingly).}
}
\value{
\itemize{
  \item \code{pileup} and \code{depth}: a CountSignals object with a signal per region
  \item \code{count}: a vector with one element per region or, if \code{ss==TRUE},
  a matrix with one column per region and two rows (sense and antisense).
}
}
\description{
Functions for extracting count signals from a bam file.

\code{count}: for each range, count the reads whose 5' end map in it.

\code{pileup}: for each base pair in the ranges, compute the number of reads whose
5' end maps there.

\code{depth}: for each base pair in the ranges, compute the number of reads
covering it.
}
\details{
A read position is always specified by its 5' end, so a read mapping to the reference strand
is positioned at its leftmost coordinate, a read mapping to the alternative strand
is positioned at its rightmost coordinate. This can be changed using the \code{shift} parameter.
}
\examples{
## TOY DATA ##
library(GenomicRanges)
bampath <- 
system.file("extdata", "randomBam.bam", package="bamsignals")
genes <- 
get(load(system.file("extdata", "randomAnnot.Rdata", package="bamsignals")))


## THE FUNCTION 'count' ##
#count how many reads map in each region (according to 5' end)
v <- count(genes, bampath)
#plot it
labs <- paste0(seqnames(genes), ":", start(genes), "-", end(genes))
par(mar=c(5, 6, 4, 2))
barplot(v, names.arg=labs, main="read counts per region", las=2, 
	horiz=TRUE, cex.names=.6)

#distinguish between strands
v2 <- count(genes, bampath, ss=TRUE)
#plot it
par(mar=c(5, 6, 4, 2))
barplot(v2, names.arg=labs, main="read counts per region", las=2, 
	horiz=TRUE, cex.names=.6, col=c("blue", "red"), legend=TRUE)



## THE FUNCTIONS 'pileup' and 'depth' ##
#count how many reads map to each base pair (according to 5' end)
pu <- bamsignals::pileup(genes, bampath)
#count how many reads cover each base pair
du <- depth(genes, bampath)
#plot it
xlab <- "offset from start of the region"
ylab <- "reads per base pair"
main <- paste0("read coverage and profile of the region ", labs[1])
plot(du[1], ylim=c(0, max(du[1])), ylab=ylab, xlab=xlab, main=main, type="l")
lines(pu[1], lty=2)
llab <- c("covering the base pair", "5' end maps to the base pair")
legend("topright", llab, lty=c(1,2), bg="white")



## REGIONS OF THE SAME SIZE AND OPTIONS FOR 'pileup' ##
proms <- promoters(genes, upstream=150, downstream=150)
#pileup according to strand
pu_ss <- bamsignals::pileup(proms, bampath, ss=TRUE)
#compute average over regions
avg_ss <- apply(alignSignals(pu_ss), 2, rowMeans)

#pileup using a strand-specific shift
pu_shift <- bamsignals::pileup(proms, bampath, shift=75)
#compute average over regions
avg_shift <- rowMeans(alignSignals(pu_shift))

#pileup using a strand-specific shift and a binning scheme
binsize <- 20
pu_shift_bin <- bamsignals::pileup(proms, bampath, shift=75, binsize=binsize)
#compute average over regions
avg_shift_bin <- rowMeans(alignSignals(pu_shift_bin))

#plot it
xs <- -149:150
main <- paste0("average read profile over ", length(proms), " promoters")
xlab <- "distance from TSS"
ylab <- "average reads per base pair"
plot(xs, avg_shift, xlab=xlab, ylab=ylab, main=main, type="l", 
	ylim=c(0, max(avg_shift)))
lines(xs, avg_ss["sense",], col="blue")
lines(xs, avg_ss["antisense",], col="red")
lines(xs, rep(avg_shift_bin/binsize, each=binsize), lty=2)
llabs <- 
c("sense reads", "antisense reads", "with shift", "binned and with shift")
legend("topright", llabs, col=c("blue", "red", "black", "black"),
	lty=c(1,1,1,2), bg="white")

}
\seealso{
\code{\link{CountSignals}} for handling the return value of
\code{pileup} and \code{depth}
}

