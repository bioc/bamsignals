---
title: "Introduction to the bamsignals package"
author: "Alessandro Mammana and Johannes Helmuth"
date: "`r Sys.Date()`"
output:
   BiocStyle::html_document:
      toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to the bamsignals package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# Introduction to the bamsignals package

The goal of the bamsignals package is to load count data from bam files as easily and quickly as possible. A typical workflow without the bamsignals package would first require to load the reads in R (for example using the Rsamtools package), and then process them and convert them into counts. The bamsignals packages merges these two steps into one using efficient C code, which makes the whole process easier and faster.

## Loading toy data

We will use the following libraries (which are all required for installing bamsignals).
```{r message = FALSE}
library(GenomicRanges)
library(Rsamtools)
library(bamsignals)
```

In the following we will use a sorted and indexed bam file and a gene annotation.
```{r}
bampath <- system.file("extdata", "randomBam.bam", package="bamsignals")
genes <- get(load(system.file("extdata", "randomAnnot.Rdata", package="bamsignals")))
genes
```

The chromosome names in the bam file and those in the `GenomicRanges` object need to match. Additionally, the bam file needs to be sorted and indexed.

```{r}
#sequence names of the GenomicRanges object
seqinfo(genes)
#sequence names in the bam file
bf <- Rsamtools::BamFile(bampath)
seqinfo(bf)
#checking if there is an index
file.exists(gsub(".bam$", ".bam.bai", bampath))

```

## Counting reads in given ranges

### Basic counting
Let's count how many reads map to the promoter regions of our genes. Using the `count` function, this is straightforward.

```{r}
proms <- GenomicRanges::promoters(genes, upstream=100, downstream=100)
counts <- count(proms, bampath, verbose=FALSE)
str(counts)
```
The object `counts` is a vector of the same length as the number of ranges that we are analyzing, the `i`-th count corresponds to the `i`-th range.

### Accounting for fragment length
With the count function a read is counted into a range if the 5' end of the read falls in the range. This might be appropriate when analyzing DNase I hypersensitivity tags, however for ChIP-seq data the immunoprecipitated protein is normally located downstream with respect to the 5' end of the sequenced reads. To correct for that, it is possible to count reads with a strand-specific shift, i.e. reads will be counted in a given region if the shifted 5' end falls in the region. Note that this shift will move reads mapped to the positive strand to the right and reads mapped to the negative strand to the left with respect to the reference orientation. The shift should correspond approximately to half of the average length of the fragments in the sequencing experiment.

```{r}
counts <- count(proms, bampath, verbose=FALSE, shift=75)
str(counts)
```

### Counting on each strand separately
Sometimes it is necessary to consider the two genomic strands separately. This is achieved with the `ss` option (separate strands, or strand-specific), and depends also on the strand of the `GenomicRanges` object.

```{r}
strand(proms)
counts <- count(proms, bampath, verbose=FALSE, ss=TRUE)
str(counts)
```

Now `counts` is a matrix with two rows, one for the sense strand, the other for the antisense strand. Note that the sense of a read is decided also by the region it falls into, so if both the region and the read are on the same strand the read is counted as a sense read, otherwise as an antisense read.

## Read profiles for each region

If you are interested in counting how many reads map to each base pair of your genes, the `pileup` function might save you a day.
```{r}
sigs <- bamsignals::pileup(genes, bampath, verbose=FALSE)
sigs
```
The `CountSignals` class is a read-only container for count vectors. Conceptually it is like a list of vectors, and in fact it can be immediately converted to that format.
```{r}
#CountSignals is conceptually like a list
lsigs <- as.list(sigs)
stopifnot(length(lsigs[[1]])==length(sigs[1]))
#sapply and lapply can be used as if we were using a list
stopifnot(all(sapply(sigs, sum) == sapply(lsigs, sum)))
```

Similarly as for the `count` function, the `CountSignals` object has as many elements (called signals) as there are ranges, and the `i`-th signal corresponds to the `i`-th range.

```{r}
stopifnot(all(width(sigs)==width(genes)))
```

### Counting on each strand separately
As for the `count` function, the reads can be counted for each strand separately
```{r}
sssigs <- bamsignals::pileup(genes, bampath, verbose=FALSE, ss=TRUE)
sssigs
```
Now each signal is a matrix with two rows.
```{r}
str(sssigs[1])
#summing up the counts from the two strands is the same as using ss=FALSE
stopifnot(colSums(sssigs[1])==sigs[1])
#the width function takes into account that now the signals are strand-specific
stopifnot(width(sssigs)==width(sigs))
#the length function does not, a strand-specific signal is twice as long as before
stopifnot(length(sssigs[1])==2*length(sigs[1]))
```
Let's summarize this with a plot
```{r}
xlab <- "offset from start of the region"
ylab <- "counts per base pair (negative means antisense)"
main <- paste0("read profile of the region ", seqnames(genes)[1], ":", start(genes)[1], "-", end(genes)[1])
plot(sigs[1], ylim=c(-max(sigs[1]), max(sigs[1])), ylab=ylab, xlab=xlab, main=main, type="l")
lines(sssigs[1]["sense",], col="blue")
lines(-sssigs[1]["antisense",], col="red")
legend("topright", c("sense", "antisense", "both"), col=c("blue", "red", "black"), lty=1)
```

### Regions of the same width
In case our genomic ranges have all the same width, a `CountSignals` object can be immediately converted into a matrix, or an array, with the `alignSignals` function
```{r}
#The promoter regions have all the same width
sigs <- bamsignals::pileup(proms, bampath, ss=FALSE, verbose=FALSE)
sssigs <- bamsignals::pileup(proms, bampath, ss=TRUE, verbose=FALSE)

sigsMat <- alignSignals(sigs)
sigsArr <- alignSignals(sssigs)

```

The last dimension of the resulting array (or matrix) represents the different regions, the second-last one represents the base pairs in each region, and in the strand-specific case, the first-one represents the strand of the signal. To change that use the `t` function (for matrices) or `aperm` (for arrays).

```{r}
#the dimensions are [base pair, region]
str(sigsMat)
#the dimensions are [strand, base pair, region]
str(sigsArr)

stopifnot(all(sigsMat == sigsArr["sense",,] + sigsArr["antisense",,]))
```

Computing the average read profile at promoters is now straightforward
```{r}
avgSig <- rowMeans(sigsMat)
avgSenseSig <- rowMeans(sigsArr["sense",,])
avgAntisenseSig <- rowMeans(sigsArr["antisense",,])
ylab <- "average counts per base pair"
xlab <- "distance from TSS"
main <- paste0("average profile of ", length(proms), " promoters")
xs <- -99:100
plot(xs, avgSig, ylim=c(0, max(avgSig)), xlab=xlab, ylab=ylab, main=main, type="l")
lines(xs, avgSenseSig, col="blue")
lines(xs, avgAntisenseSig, col="red")
legend("topright", c("sense", "antisense", "both"), col=c("blue", "red", "black"), lty=1)
```

### Binning counts

Very often it is better to count reads mapping to small regions instead of single base pairs. Bins are small non-overlapping regions of fixed size tiling a larger region. Instead of splitting your regions of interest into bins, it is easier and more efficient to provide the `binsize` option to `pileup`.
```{r}

binsize <- 20
binnedSigs <- bamsignals::pileup(proms, bampath, binsize=binsize)
stopifnot(all(width(binnedSigs)==ceiling(width(sigs)/binsize)))
binnedSigs
```
In case the regions' widths are not multiples of the bin size, a warning will be issued and the last bin of the region will be smaller than the others (where "last" depends on the orientation of the region).

Binning means considering a signal at a lower resolution.
```{r}
avgBinnedSig <- rowMeans(alignSignals(binnedSigs))
#the counts in the bin are the sum of the counts in each base pair
stopifnot(all.equal(colSums(matrix(avgSig, nrow=binsize)),avgBinnedSig))
#let's plot it
ylab <- "average counts per base pair"
plot(xs, avgSig, xlab=xlab, ylab=ylab, main=main, type="l")
lines(xs, rep(avgBinnedSig, each=binsize)/binsize, lty=2)
legend("topright", c("base pair count", "bin count"), lty=c(1, 2))

```

## Read coverage

If instead of the 5' end of each read you want to count how many reads overlap each base pair, you should check out the `depth` function.
```{r}
covSigs <- bamsignals::depth(genes, bampath, verbose=FALSE)
puSigs <- bamsignals::pileup(genes, bampath, verbose=FALSE)
xlab <- "offset from start of the region"
ylab <- "reads per base pair"
main <- paste0("read coverage and profile of the region ", seqnames(genes)[1], ":", start(genes)[1], "-", end(genes)[1])
plot(covSigs[1], ylim=c(0, max(covSigs[1])), ylab=ylab, xlab=xlab, main=main, type="l")
lines(puSigs[1], lty=2)
legend("topright", c("covering the base pair", "5' end maps to the base pair"), lty=c(1,2))
```






